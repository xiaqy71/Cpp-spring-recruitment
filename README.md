# Cpp 2024春季招聘面试笔记

This is the repository I use to keep track of spring 2024 recruiting (c++)

这是我用于记录2024春招(c++)的仓库


- [Cpp 2024春季招聘面试笔记](#cpp-2024春季招聘面试笔记)
    - [计算机基础](#计算机基础)
      - [原码 反码 补码](#原码-反码-补码)
      - [大端vs小端](#大端vs小端)
    - [C语言](#c语言)
      - [函数参数入栈顺序及i++,++i实现](#函数参数入栈顺序及ii实现)
      - [函数指针 \&\& 函数指针数组 \&\& 指向函数指针数组的指针](#函数指针--函数指针数组--指向函数指针数组的指针)
      - [隐式类型转换法则](#隐式类型转换法则)
      - [设置、清除、切换和检查单个位](#设置清除切换和检查单个位)
    - [C++](#c)
    - [数据库](#数据库)
    - [系统编程](#系统编程)
    - [网络编程](#网络编程)

### 计算机基础
---

#### 原码 反码 补码

##### 原码

原码，符号位加真值的绝对值

```
+3[原] = 00000011
-3[原] = 10000011
```

##### 反码

正数的反码是其原码

负数的反码，符号位不变，其余各位`~`(取反)

```
+3[反] = 00000011[原] = 00000011[反]
-3[反] = 10000011[原] = 11111100[反]
```

##### 补码

正数的补码是其原码

负数的补码，是其反码+1

```
+3[补] = 00000011[原] = 00000011[反] = 00000011[补]
-3[补] = 00000011[原] = 11111100[反] = 11111101[补]
```

反码和补码，不能直接看出其实际的数值， 需要转换成原码后计算

数据在内存中均以补码形式存储，方便计算(做加法无需考虑符号)

#### 大端vs小端

##### 什么是字节序

字节顺序，又称端序或尾序（英语：Endianness），在计算机科学领域中，指电脑内存中或在数字通信链路中，组成多字节的字的字节的排列顺序。

在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&x的值为0x100。且x的四个字节将被存储在电脑内存的0x100, 0x101, 0x102, 0x103位置。

字节的排列方式有两个通用规则。例如，将一个多位数的低位放在较小的地址处，高位放在较大的地址处，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。

例如假设上述变量x类型为int，位于地址0x100处，它的值为0x01234567，地址范围为0x100~0x103字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：0x100: 0x01, 0x101: 0x23,..。而小端法将是：0x100: 0x67, 0x101: 0x45,..。

##### 大端序

![大端序](imgs/image.png)

低位高地址

##### 小端序

![小端序](imgs/image-1.png)

低位低地址

> tips: 为了保证传送顺序的一致性, 网际协议使用大端字节序来传送数据。

**参考**

[维基百科-字节序](https://zh.wikipedia.org/zh-cn/%E5%AD%97%E8%8A%82%E5%BA%8F)

### C语言
---

#### 函数参数入栈顺序及i++,++i实现

i++

```c
// i++
int j = i;
i = i + 1;
return j;
```

++i

```c
// ++i
i = i + 1;
return i;
```

```c
int i = 0;
printf("%d %d %d %d\n", ++i, i++, i++, ++i); // 4 2 1 4
```

#### 函数指针 && 函数指针数组 && 指向函数指针数组的指针

##### 函数指针

本质上是一个指针，指向一个函数

- 定义函数指针

`void (*fp)(int a, int b);`

函数指针是专用的，格式要求很强，返回值、参数类型、参数个数都必须相同

- 如何给函数指针赋值

```c
void f(int a, int b) {

}

void (*fp)(int a, int b) = data;
```

- 如何调用函数指针

```c
p2(a, b);
(*p2)(a, b);
```

##### 函数指针数组

声明一个数组，里面存储的类型是指向函数的指针

```c
int ret;

int *add(int a, int b) {
    ret = a + b;
    return &ret;
}

int main(int argc, char*argv[]) {

    int a = 10;
    int b = 20;

    int *p = add(a, b);

    printf("%d\n", *p);

    return 0;
}

```

##### 函数指针数组

```c
int Add(int x, int y) {
    return x + y;
}

int Sub(int x, int y) {
    return x - y;
}

int MUl(int x, int y) {
    return x * y;
}

int Div(int x, int y) {
    return x / y;
} 

int main(int argc, char*argv[]) {

    int (*pf1)(int, int) = Add;
    int (*pf2)(int, int) = Sub;
    int (*pf3)(int, int) = Mul;
    int (*pf4)(int, int) = Div;

    // 函数指针数组
    int (*pf[4])(int, int) = {Add, Sub, Mul, Div};

    // 调用

    for (int i = 0;i < 4; i++) {
        pf[i](2, 5);
    }
}

```

#### 隐式类型转换法则

若参与运算的数据类型相同则运算所得结果的数据类型也为该数据类型。若参与运算的数据类型不同，则先转换成同一类型，然后进行运算。
1) 转化按数据长度增加的方向进行，以保证精度不降低。例如int类型和long类型运算时，先把int类型转换成long类型后再进行运算
2) 即当参加算数或比较运算的两个操作数类型不统一时，将简单类型向复杂类型转换

$$char->short->int->long->float->double$$

3) 在赋值语句中，赋值号两边数据类型一定是相兼容的类型，如果等号两边数据类型不兼容，语句在编译时会报错

#### 设置、清除、切换和检查单个位

设置第N位：`Number |= (1ul << nth Position)`

设置第N位意味着如果第N位为0，则将其设置为1，如果为1，则保持不变。在C中，按为或运算用于设置整数数据类型的位。据我们所知 | 计算一个新的整数值，其中每个位的位置只有当操作数(数据类型)在该位置为1时才为1。

简而言之，如果其中任何一位为1，则可以说两位的按位与始终为1

0 | 0 = 0  
1 | 0 = 1  
0 | 1 = 1  
1 | 1 = 1  

清除位：`Number &= ~(1UL << nth Position)`

清除位意味着如果第N位为1，则将其清为0，如果为0，则保持不变。按位与运算符用于清除位整数数据类型。如果其中任何一位为零，则两位的“与”始终为零。

0 & 0 = 0  
1 & 0 = 0  
0 & 1 = 1  

检查位:`Bit = Number & (1UL << nth Position)`

要检查第n位，先将第n个“1” 位置向左移动，然后将其与数字“与”

切换位：`Numebr ^ = (1UL << nth Position)`

切换位表示如果第N位为1，则将其更改为0， 如果为0， 则将其更改为1。按位异或运算符用于切换整数数据类型的位。要切换第n个位移位，将第n个位置的'1'向左移动并异或它

0 ^ 0 = 1  
1 ^ 0 = 1  
0 ^ 1 = 0  
1 ^ 1 = 1  

### C++

### 数据库

### 系统编程

### 网络编程